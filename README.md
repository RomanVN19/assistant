# Assistant

... developing ...

TODO
- dialog + confirm
- client app by structure
- own form with proxy calls

Логика. Никак не смешать серврный код с клиентским, поэтому делим на общее -
- список сущностей - структура, и отдельные моменты для клиента и сервера.
App - общий список сущностей со списком полей
AppClient - клиентский код - формы и т.п.
AppServer - серверный код - серверные функции
client - точка входа клиенского приложнения


Архитектурные требования:
- (1) переиспользование кода повторяющихся задач.
- (2) индивидуальные модификации при неизменности кода исходного решения.

Синтетические кейсы:
- (1) Общие сущности: Контрагенты - актуально и для учета и для CRM с зависимым справочником "Виды деятельности"
- (2) Доп поля. Добавить колонку "комментарий" в таб. части приходов.
- (1) Поля "Создал", "Изменил" заполняемые на сервере и отображаемые на форме
- (2) Разные названия прихода ден средств: "Приходы" "Поступления"
- (2) Другой метод расчета себестоимости списания (вместо "по средней", по цене из номенклатуры)

Sequelize позволяет создавать методы экземпляров и моделей. "Расширения" будут отрабатывать сначала
на уровне платформы, а потом будет создаваться модели.
Нет смысла тащить методы сущностей в методы модели - это простые функции - пусть
они остаются в сущностях. А вот для экземпляров удобно использовать sequelize.
(если они вообще потребуются).

Реализация (2) в формах будет внутри конструктора, где чз content можно будет поменять
любые атрибуты элементов формы и также добавить/удалить эти элементы.

Для реализации (2) приложения вместо работы с моделями seq будут работать с предопредленными методами сущностей. При этом будут возможны хаки типа проверки прав или расширения спец решения до сервиса.

Реализация (1) что на клиенте что на сервере объективно зависит не столько от платформы, сколько от способа реализации приложений на ней. Подход такой же как и сейчас в js разработке - можно решать свой частный случай, а можно сделать переиспользуемый модуль + доку по его использованию.

Потребуется хранить состояние пользователя. Как минимум для кэша проверки прав. Можно сделать обычные сессии. При масштабировании - увеличении кол-ва процессов - можно при попадании запроса от юзера по которому нет сессии - создавать. Это актуально для только кэша, с изменяемым состоянием не прокатит. Но вообще изменяемое состояние надо избегать, так что может обойдемся без него.

! Менеджеры разных сущностей вполне могут быть на разных серверах. При обращении из одной сущности к другой можно вызывать типа прокси класс, который будет обращаться по http к другому сервису. НЮАНС. Т.к. связи таблиц разрешаются на уровне запросов то такая схема будет работать только на замкнутой системе связей - т.е. без ссылочных полей на таблицы другого сервиса.

По факту - работа с экземплярами сущностей - метод организации кода, не более. При этом, вводится дополнительная абстрация. Не будем усложнять и оставим работу с данными на уровне "менеджеров" сущностей.

Архитектурное решение.

Приложение со стороны клиента представляет собой набор Форм, со стороны сервера - набором Сущностей. Формы, Сущности и сами Приложения описываются классами.
Требование (1) реализуется принципом разработки - выделением частей приложения в переиспользуемые модули.
Требование (2) реализуется штатными механизмами наследования и композиции классов: вместо модификации Базового решения мы либо наследуем свои классы от него либо используем их в своих классах.
